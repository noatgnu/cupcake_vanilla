name: Build Portable Distribution

on:
  release:
    types: [published]
  workflow_dispatch:

jobs:
  build:
    timeout-minutes: 60
    strategy:
      matrix:
        include:
          - os: ubuntu-latest
            arch: x86_64
            platform: x86_64-unknown-linux-gnu
            os_name: linux
          - os: windows-latest
            arch: x86_64
            platform: x86_64-pc-windows-msvc-shared
            os_name: windows
          - os: macos-13
            arch: x86_64
            platform: x86_64-apple-darwin
            os_name: macos
          - os: macos-latest
            arch: aarch64
            platform: aarch64-apple-darwin
            os_name: macos
          - os: macos-latest
            arch: aarch64
            platform: aarch64-unknown-linux-gnu
            os_name: linux

    runs-on: ${{ matrix.os }}

    steps:
    - uses: actions/checkout@v4

    - name: Get latest Python 3.11 standalone build
      id: get-python
      shell: bash
      env:
        GH_TOKEN: ${{ github.token }}
      run: |
        set +e
        PLATFORM="${{ matrix.platform }}"
        echo "Looking for platform: $PLATFORM"

        echo "Fetching release data..."
        HTTP_CODE=$(curl -sL -w "%{http_code}" -o /tmp/release.json \
          -H "Accept: application/vnd.github+json" \
          -H "Authorization: Bearer ${GH_TOKEN}" \
          -H "X-GitHub-Api-Version: 2022-11-28" \
          "https://api.github.com/repos/astral-sh/python-build-standalone/releases/latest")

        echo "HTTP Status Code: $HTTP_CODE"

        if [ "$HTTP_CODE" != "200" ]; then
          echo "ERROR: Failed to fetch release data (HTTP $HTTP_CODE)"
          cat /tmp/release.json
          exit 1
        fi

        TAG=$(python3 -c "import json; data=json.load(open('/tmp/release.json')); print(data.get('tag_name', 'unknown'))")
        echo "Latest release tag: $TAG"

        if [ "$TAG" = "unknown" ]; then
          echo "ERROR: Failed to parse tag_name from release data"
          exit 1
        fi

        DOWNLOAD_URL=$(python3 -c "import json; data = json.load(open('/tmp/release.json')); assets = data.get('assets', []); platform = '${PLATFORM}'; matches = [asset['browser_download_url'] for asset in assets if 'cpython-3.11' in asset.get('name', '') and platform in asset.get('name', '') and asset.get('name', '').endswith('install_only.tar.gz') and '_stripped' not in asset.get('name', '')]; print(matches[0] if matches else '')")

        if [ -z "$DOWNLOAD_URL" ]; then
          echo "Error: Could not find Python 3.11 for platform $PLATFORM"
          echo "Sample of available Python 3.11 assets:"
          python3 -c "import json; data=json.load(open('/tmp/release.json')); [print(asset['name']) for asset in data.get('assets', []) if 'cpython-3.11' in asset.get('name', '') and 'install_only' in asset.get('name', '')]" | head -10
          exit 1
        fi

        set -e

        echo "download_url=$DOWNLOAD_URL" >> $GITHUB_OUTPUT
        echo "Found Python download: $DOWNLOAD_URL"

    - name: Download and extract portable Python
      shell: bash
      run: |
        curl -L -o python.tar.gz "${{ steps.get-python.outputs.download_url }}"
        mkdir -p python_portable
        tar -xzf python.tar.gz -C python_portable
        rm python.tar.gz

    - name: Create virtual environment and install dependencies
      shell: bash
      run: |
        if [ "$RUNNER_OS" == "Windows" ]; then
          PYTHON_BIN="python_portable/python/python.exe"
        else
          PYTHON_BIN="python_portable/python/bin/python3"
        fi

        $PYTHON_BIN -m venv .venv

        if [ "$RUNNER_OS" == "Windows" ]; then
          .venv/Scripts/python.exe -m pip install --upgrade pip
          .venv/Scripts/pip.exe install -r requirements.txt
        else
          .venv/bin/python -m pip install --upgrade pip
          .venv/bin/pip install -r requirements.txt
        fi

    - name: Create portable distribution
      shell: bash
      run: |
        if [ "${{ github.event_name }}" == "release" ]; then
          VERSION="${{ github.event.release.tag_name }}"
          VERSION="${VERSION#v}"
        else
          VERSION="dev-$(date +%Y%m%d)"
        fi

        DIST_NAME="cupcake_vanilla-${VERSION}-${{ matrix.os_name }}-${{ matrix.arch }}"
        DIST_DIR="dist/${DIST_NAME}"

        mkdir -p "${DIST_DIR}"

        echo "Copying virtual environment (excluding cache)..."
        mkdir -p "${DIST_DIR}/venv"
        if [ "$RUNNER_OS" == "Windows" ]; then
          rsync -a --exclude='__pycache__' --exclude='*.pyc' --exclude='pip-cache' .venv/ "${DIST_DIR}/venv/" || cp -r .venv "${DIST_DIR}/venv"
        else
          rsync -a --exclude='__pycache__' --exclude='*.pyc' --exclude='pip-cache' .venv/ "${DIST_DIR}/venv/" || cp -r .venv "${DIST_DIR}/venv"
        fi

        echo "Copying source code..."
        cp -r ccv ccc ccm ccmc ccrv ccsc cupcake_vanilla manage.py "${DIST_DIR}/"

        if [ -f "pyproject.toml" ]; then
          cp pyproject.toml "${DIST_DIR}/"
        fi
        if [ -f "poetry.lock" ]; then
          cp poetry.lock "${DIST_DIR}/"
        fi

        cat > "${DIST_DIR}/activate.sh" << 'EOF'
        #!/bin/bash
        SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
        source "${SCRIPT_DIR}/venv/bin/activate"
        export PYTHONPATH="${SCRIPT_DIR}:${PYTHONPATH}"
        echo "Cupcake Vanilla environment activated"
        echo "Run: python manage.py runserver"
        EOF

        cat > "${DIST_DIR}/activate.bat" << 'EOF'
        @echo off
        set SCRIPT_DIR=%~dp0
        call "%SCRIPT_DIR%venv\Scripts\activate.bat"
        set PYTHONPATH=%SCRIPT_DIR%;%PYTHONPATH%
        echo Cupcake Vanilla environment activated
        echo Run: python manage.py runserver
        EOF

        chmod +x "${DIST_DIR}/activate.sh"

        cd dist
        tar -czf "${DIST_NAME}.tar.gz" "${DIST_NAME}"

    - name: Upload artifact
      uses: actions/upload-artifact@v4
      with:
        name: cupcake_vanilla-${{ matrix.os }}-${{ matrix.arch }}
        path: dist/*.tar.gz
        retention-days: 30

    - name: Upload to Release
      if: github.event_name == 'release'
      uses: softprops/action-gh-release@v1
      with:
        files: dist/*.tar.gz
        tag_name: ${{ github.event.release.tag_name }}
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
